# C#

## Начало работы:
 __dotnet new console__ - создать новый проэкт

 **dotnet run** - запустить проэкт

 ### Обращзение к консоли

 __Console.__

 __WriteLine(....)__ - В конце перейти,на новую строку

 __Write(...)__ - Вывод в одну строку

 __ReadLine(...)__ - Считать строку из терминала

 __Метод интерполяции:__

Console.WriteLine(__$__"текс __{__ имя_переменной __}__ текс");

## Типы данных
     int - тип данных,целых чисел (3)/ так же существует подобныт тип данных - Long
     double - тип данных,вещественных чисед (3,3)/ так же существует подобныт тип данных - Float
     string - тип данных строк
     bool - тип логических данных (Да/Нет(1/2))
     var - тип данных универсальный,он сам подбирает тип данных под данные,которые ему присваивают: (Int) var num = 3; (string) var name = Console.ReadLine()
    
## Циклы

1. __while__ - цикл

*while (условие) { действия цикла } ;*

*Например:
int i = 6; while (i > 0) { Console.WriteLine(i); i--; }*

2. __foreach__ - цикл


*foreach(тип_данных переменная in коллекция) { // действия цикла }* 

После оператора foreach в скобках сначала идет определение переменной. Затем ключевое слово in и далее коллекция, элементы которой надо перебрать.
При выполнении цикл последовательно перебирает элементы коллекции и помещает их в переменную, и таким образом в блоке цикла мы можем выполнить с ними некоторые действия.
Например, возьмем строку. Строка по сути - это коллекция символов. И .NET позволяет перебрать все элементы строки - ее символы с помощью цикла foreach.

*foreach(char c in "Tom") { Console.WriteLine(c); }*
 
Здесь цикл foreach пробегается по всем символам строки "Tom" и каждый символ помещает в символьную переменную c. В блоке цикла значение переменной cвыводится на консоль. Поскольку в строке "Tom" три символа, то цикл выполнится три раза. Консольный вывод программы:
T o m
Стоит отметить, что определяемая в объявлении цикла должна по типу соответствовать типу элементов перебираемой коллекции. Так, элементы строки - значения типа char - символы. Поэтому переменная c имеет тип char. Однако в реальности не всегда бывает очевидно, какой тип представляют элементы коллекции. В этом случае мы можем определить переменную с помощью оператора var:

*foreach(var c in "Tom") { Console.WriteLine(c); }* 

3. __for__ - цикл

Цикл for имеет следующее формальное определение:

*for ([действия_до_выполнения_цикла]; [условие]; [действия_после_выполнения]) { // действия }* 

Объявление цикла for состоит из трех частей. Первая часть объявления цикла - некоторые действия, которые выполняются один раз до выполнения цикла. Обычно здесь определяются переменные, которые будут использоваться в цикле.
Вторая часть - условие, при котором будет выполняться цикл. Пока условие равно true, будет выполняться цикл.
И третья часть - некоторые действия, которые выполняются после завершения блока цикла. Эти действия выполняются каждый раз при завершении блока цикла.
После объявления цикла в фигурных скобках помещаются сами действия цикла.

Например:

*for (int i = 1; i < 4; i++) { Console.WriteLine(i); }*

•Здесь первая часть объявления цикла - int i = 1 - создает и инициализирует переменную i.

•Вторая часть - условие i < 4. То есть пока переменная i меньше 4, будет выполняться цикл.

•И третья часть - действия, выполняемые после завершения действий из блока цикла - увеличение переменной i на единицу.

### Методы

    Int32.Parse(string) - Преобразует строковое представление числа в эквивалентное ему 32-битовое целое число со знаком.

    Int32.TryParse(string,out int32) Преобразует строковое представление числа в эквивалентное ему 32-битовое целое число со знаком. Возвращает значение, указывающее, успешно ли выполнена операция.

    String.ToLower() - Возвращает копию этой строки, переведенную в нижний регистр.

    Func<T,TResult> *имя*  -  Инкапсулирует метод с одним параметром, который возвращает значение типа, указанного в параметре TResult

    string.IndexOf('искомый символ',int32*Позиция, с которой начинается поиск*,int32*Количество позиций знаков для проверки*) - поиск символа по строчке(str.IndexOf('o') -  так тоже можно искользовать)

    indexOfAny(Char[])  -  Возвращает индекс с отсчетом от нуля первого обнаруженного в данном экземпляре символа из указанного массива символов

    String.Insert(Int32, String) - Возвращает новую строку, в которой указанная строка вставлена в указанную позицию индекса в этом экземпляре.


### Операторы
    
    ??=  -  присваивает значение правого операнда левому операнду только в том случае, если левый операнд имеет null значение
    ??  -  возвращает значение своего операнда слева, если его значение не равно null. В противном случае он вычисляет операнд справа и возвращает его результат
    ?  -  тернарный условный оператор(верно ли это условие? да: нет)
    =>  -  лямбда
    

### Array and List

#### Array:

    *тип данных*[] *название массива* = new *тип данных*[]  =  создание одномерного массива
    *тип данных*[,] *название массива* = new *тип данных*[,]  =  создание двумерного массива
    *название массива*.Length  =  длина одномерного массива
    *название массива*.GetLength(0)  =  длина двумерного массива по строкам
    *название массива*.GetLength(1)  =  длина двумерного массива по столбцам



#### List:(Коллекция)

    List<*тип данных*> *название листа* = new List<*тип данных*>()   -  создание нового листа(списка)

    *название листа*.Count  -  размер листа

    *название листа*.Add(*переменная которая добавиться в лист*)  -  добавить что-то в лист

    *название листа*.AddRange(new *тип данных* {значения})  -  добавить в лист несколько значений

    *название листа*.RemoveAt(индекс)  -  удалить из листа переменные с по индексу

    *название листа*.Remove(Значение)  - удалить из листа первою переменную с определенным значением

    *название листа*.Clear()  -  отчистить лист

    *название листа*.Insert(*индекс*,*значение*)  -  добавить в лист значение в определенное место
    
    *название листа*.IndexOf(значение)  -  узнать индекс искомого значения в листе
    
    

#### Queue:(Коллекция)
*Очередь*

    Queue<*тип данных*>*название очереди* = new Queue<*тип данных*>();  -  создать очередь

    *название очереди*.Enqueue(*значение*)  -  добавить значение в очередь
 
    *название очереди*.Dequeue()  -  приступить к элементу первому в очереди и вывести его из очереди
 
    *название очереди*.Peek()  -  приступить к элементу первому в очереди,не выводя его из очереди
 


#### Stack:(Коллекиця)
*реверсивная очередь*

    Stack<*тип данных*> *название очереди* = new Stack<*тип данных*>()  -  создать реверсивную очередь

    *название очереди*.Push(*значение*)  -  добавить значение в очередь
    
    *название очереди*.Pop()  -   приступить к элементу последнему в очереди и вывести его из очереди
    
    *название очереди*.Peek()  -  приступить к элементу последнему в очереди,не выводя его из очереди
    


#### Dictionary(Коллекция)
*словарь*

    Dictionary<*тип данных1,тип данных2*> *название словарю* = new Dictionary<*тип данных1,тип данных2*>  - создать словарь
    
    *Название словаря*.Add(*значение1,значение2*)  -  добавить пару значений(Ключ и его значение)
    
    *Название словаря*.Remove(*значение1(ключ)*)  -  удалить из словаря значения
    
    

#### HashSet(Коллекция)
*множество*

     HashSet<*тип данных*>*название множества* = new HashSet<*тип данных*>()  -  создать множество
     *Название множества*.add(значение)  -  добавить во множество уникальное значение
     *Название множества*.UnionWith(*название другой коллекции данных*)  -  обьеденить множество с другим множеством/коллекции данных,записывая в него только уникальные значения,которые не имеют дубликатов
     *Название множества*.IntersectWith(*название другой коллекции данных*)  -  обьеденить множество с другим множеством/коллекции данных,записывая в него только значния,которые пересекаются в обоих коллекциях данных
     *Название множества*.SymmetricExceptWith(*название другой коллекции данных*)  -  обьеденить множество с другим множеством/коллекции данных,записывая в него только значения,которые не имеют пересечения в обоих коллекциях данных
     *Название множества*.ExceptWith(*название другой коллекции данных*)  -  обьеденить множество с другим множеством/коллекции данных,удаляя из него те значения, которые повторяются во второй коллекции 

### Классы 



### Связи

#### Has-a                                                                 
Один обьект содержит в себе другой                                                            
     
    class name1                                                             
    {}                                                                      
    class name2                                                             
    {                                                                       
    class1                                                                  
    }                                                                       
                                                                            
#### Is-a
Наследние
      
    class name1
    {
    public name1(arg1,arg2)
    }
    calss name2 : name1
    {
    public name2(arg1,agr2) : base(arg1,arg2)
    }
    
    

### Свойства
    
    public *тип данных* *имя переменной(Name1)*
    {
     get
     {
      return _name1;
     }
     private set
     {
     _name1 = value
     }
    }
    
Свойства бывают: -автореализуемом , -абслуживаемые(в которых будут дописанны проверки)



### Виртуальные методы

    Class Name1
    {
     public virtual void NameName9()
     {
      //code
      }
    }
    
    Class Name2 : Name1
    {
     public override void NameName9()
     {
      //(либо использование того же кода) base.NameName9()
      //либо какие-то другие значения этому методу
     }
    }
